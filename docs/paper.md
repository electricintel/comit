##3ii: A public service application on the blockchain

###What is blockchain?
While “the blockchain” is commonly portrayed as a singular entity, it is in fact the integration of numerous technologies- P2P networks, consensus engines, hashing algorithms, security protocols, and application state structures. The blockchain has many incarnations, the most well known being Bitcoin. However, blockchain means different things to different people, and individuals and organizations have disparate ideas regarding how blockchains should be implemented and what purposes they should serve. Despite the range of opinions, many parties see value in existing and future applications of the blockchain across various industries. Blockchain technology has already made a large footprint in the financial sector with the abundance of cryptocurrencies pervading major banks and institutions while influencing how people across the world manage their personal finances. 

In theory, the blockchain provides an immutable ledger of transactions, be it financial transactions, votes, messages- which is replicated across a network of machines. Why is this important? Well, it’s really hard for a bunch of computers that are not running on a single server system to agree on what the entries in the ledger should be if they are all trying to listen and talk to it at the same time. Think about trying to have a conference call with a hundred other people. Unless there were well-defined rules about who should talk when, and those rules were carefully followed, it would be really difficult to have a meaningful conversation. If we think of computers on the blockchain as people on a conference call, we cannot impose those rules on the former; the point of the blockchain is that everyone can talk to it at the same time and reach some consensus as to what the meeting minutes are. This is no easy task, and tackling it requires the integration of the numerous technologies aforementioned. And we haven’t even considered the possibility that some people on the call want to misinform others, invalidate or obscure legitimate information. How will the integrity of the conference call withstand these malicious ends?

Having this immutable ledger replicated across personal computers in a network is really awesome though (once we have it). The ledger can be used to verify transaction history and the values of digital assets. This is a big reason why blockchain has found a home in finance; it systemizes and ideally secures the accounting process. But blockchain technology is not limited to finance and cryptocurrencies. Blockchain can help governments, public service organizations, and their constituencies.

If you would like to dig deeper into blockchain technology, I recommend reading about Bitcoin and checking out Ethereum. If you like blog posts, poke around Medium. I found two articles which, I believe, nicely articulate the importance of blockchains. The [first](https://medium.com/@wmougayar/explaining-the-blockchain-via-a-google-docs-analogy-56326b1bbe58#.cc31fdupy) provides a high-level discussion of blockchains with a google docs analogy; the [second](https://medium.com/@ConsenSys/programmable-blockchains-in-context-ethereum-s-future-cd8451eb421e#.n10mf920z) offers a historical overview of the internet, databases, and where blockchains fit into the schema. If you’re more of a podcast person, Epicenter Bitcoin has some great talks with leading industry professionals and academics. A lot of blockchain companies publish white papers about their technologies. These can be informative resources, though often very technical.

###Blockchain in public services
Blockchains enable synchronization of databases that, up until now, have been siloed. Furthermore, the blockchain redefines what a database is; how it is established and operated. Today, most big companies (e.g. Facebook) and governments manage their own server systems, through which they provide online services, run user applications, receive and store data. When you log onto Facebook, you are sending an HTTP request through your web browser to a Facebook server somewhere. Server operations check that your credentials are valid and then send an HTTP response back to you. You receive the response in your browser, and you can see your news feed, check your notifications nad messages.

While this explanation neglects many of the finer details, it illustrates that we do not (usually) interact directly with databases. Rather, we notify or send information to a server center, managed by some administrative entity. The server retrieves data from a database, possibly alters or performs computation on it, and sends it back to us in some fashion. This is no indictment of corporate practice; however, the point remains that a single administrative entity regulates access to, management and distribution of data. Personally, you may be happy that developers and engineers at Facebook handle these issues: a company with talented personnel that runs its own centralized server system is better able to manage and deliver services. But what if the entity managing the server system is untrustworthy or incompetent? Forget about the reputation of the administrative entity- what if you are trying to prove that a digital asset is worth X amount. This is something for which you might like confirmation from other parties (e.g. market participants), even if the administrative entity (e.g. the bank) is reputable. But even the most “reputable” institutions are capable of corruption, fraud, and the like.

City governments also have servers and databases. Of course, these systems provide different services and store different data than those managed by Facebook. Nevertheless, we still have the same plot line: an administrative entity regulates access to, management and distribution of data. In the past several years, there has been a push in many U.S. cities to collect more public data and make it available to constituencies. Even when data is collected, there isn’t always the digital infrastructure necessary to make the data easily accessible. Even when the infrastructure is in place, packaging and providing of data is no easy task. Not to mention, it might be months or years before the government makes data from this year publicly available. 

I currently reside in the Chicagoland area. Chicago has a strong civic tech/social innovation scene and one of the better open data portals. The portal has historical data on many different things- properties, crime rates, police activity, traffic violations, etc.- which one can download or interact with through an API. While the open data portal is a wonderful resource for local officials, developers, and constituents, I believe a public service application on the blockchain- that is a database itself, is an important next step for the civic tech-scape. Ideally, constituents and local officials would use the application and interact directly with a decentralized database containing information that currently resides in city government servers. This would increase transparency, accessibility, and stakeholder-ship of public data.

###Introducing 3ii
3ii is a public service/311 application on the blockchain. Constituents, or users, submit service requests for issues in their local area, whether it be street potholes, traffic lights out, no garbage pick-up, or concerns that do not traditionally fall under the 311 umbrella (e.g. complaints of law enforcement misdemeanor). When a constituent submits a request through the interface, the request is appended to an immutable ledger of service requests, assuming the submission form contains necessary and valid information. Each service request in the ledger has a unique ID, with which users retreive form information. In addition, users can search forms by service, address, time posted, and status (i.e. resolved or unresolved). 

Government officials, or admins, have different permissions than users. They cannot submit service requests; however, they can resolve a form after the service request has been filled. This changes the status of the form from “unresolved” to “resolved”. Wait a second, how is this different from current systems if the government officials still have administrative privileges? Managing a centralized server system, the government has the ability to manipulate data. Deleting a service request here, altering information in a citizen complaint there, though we should hope our local government doesn’t do these things. While government officials can resolve forms and perform other special functions under the 3ii system, they should not be able to manipulate data. When an admin resolves a form, nothing about the form changes, apart from its status. A user querying the form will see that the form has been resolved by the admin at the time of resolution. If the service request has not actually been resolved  (e.g. the street light is still out), the citizen can perform his favorite civic duty: complaining! However, the government and the constituent will have a canonical chronology of events- constituent X submitted service request at 10:09 am on Tuesday, admin Y resolved form 2:35 pm on Friday, etc- to hash out the situation. 

So does 3ii just give constituents evidence to support their complaints? Yes, citizen empowerment is one of the potential benefits. However, there are two greater motivations for a system such as this, the first of which harkens back to the concept of the open data portal. It is that public data should be a communal resource. It should be something we all interact with and help to create. While open data portals are a great resource, the concept reinforces the notion that public data is something provided by the government to the constituent. The act of provision, however, implies the providing entity regulates access to, management and distribution of data. But within the context of this discussion, this is exactly what we’re trying to move away from- a singular entity managing the database. It is preferable, where possible, to faciliate cooperative development of public data between citizens and officials.

One may contend, government officials have knowledge and expertise in public service and access to certain resources, thus warranting their presiding over public data. Involving constituents in the creation and collection of public data will introduce inefficiencies into the process and yield messy outputs. To that, I quote Ethan Buchman of Tendermint when I ask, why not institute a dictatorship if we are concerned about efficiency? Jokes aside, constituent involvement in a system like 3ii will not necessarily lead to messy data or inefficiency. How? Data immutability- the second motivation of 3ii. When a constituent submits a valid service request, the form is broadcast to the network, appended to the transaction ledger and stored in a cache system, after which nothing about the form besides its status can be altered. There is no administrative entity that can modify or redact form fields; admins are only authorized to resolve forms. In a sense, each valid service request submitted by a constituent that makes it into the transaction ledger is etched in stone. Why is this so important? Many current systems have data mutability, which opens a pandora’s box of code bugs and higher-level issues that can manifest in one of many awful ways (e.g. losing personal account information or digitally held funds for X users). By ensuring immutability, or reduced mutability of public data, we can mitigate issues stemming from data manipulation. 

So constituents and local officials using the 3ii system cannot modify data. Constituents can submit service requests and search for submitted forms in real time. The former is nothing new, assuming the constituent's municipality already provides an online 311 service. The latter is. I can find historical 311 service requests in the Chicago open data portal. But my accessing the data hinges on whether/when the city government decides to provide it via the portal. Involving consituents in the creation and collection of public data does not equate to "letting them mess things up". Rather, we are providing an interface through which they can submit service requests (which they may already do), query submitted forms, and retreive form information in real time. We are maintaining the write permissions while expanding the read permissions of constituents. Government officials benefit too. While their actions are broadcast to users, increasing transparency and exposure, they also have the power of the blockchain and decentralized network at their fingertips. The integrity of the database and its content are validated not only by government but consituencies using the 3ii system.

###How it works
3ii can be conceptualized as a system of players, actions, games, managers, and scorekeepers. We already mentioned the players, local officials (admins) and their constituents (users). Users can perform a bunch of actions from different endpoints in the interface. They can create accounts, submit service requests, search for service requests, and calculate performance metrics across services and departments. To create an account, a user must enter a passphrase, after which a public and private key are displayed on the webpage. The private key is used to recover the account in case it is hacked. The user must provide his public key and passphrase when performing other actions (**for now). 

Admins can resolve forms but they cannot submit service requests. Otherwise, account registration and the action domain is pretty much the same for admins as it is with users. What if a local official spots a big pothole in the street and wants to report it via 3ii? Well, officials can have user accounts too! The point here is, we would like to establish a separation of concerns, with user accounts submitting service requests and admin accounts resolving forms. There is a lot going on with these actions, creating a surface area for attack. How do we minimize this surface area and define a framework in which actions are processed correctly? Say hello to the action listener, which waits on player requests and then executes them, following strict "smart contract" logic. I'll explain what this means in greater detail as we go on, but the real importance of the action listener, apart from its role as the initial processor, is that it commuicates to players, managers, and scorekeepers, thus defining the flow of the game. 

When a user or admin tries to perform an action, there are several steps involved in the execution of the action. First, we authorize account creditials, making sure the provided public key and passphrase match a user's or admin's public key and passphrase in the system. This is where the managers come in handy. Just as baseball managers vet recruits, our account managers vet users and admins. The account managers contain in-memory data structures with account information for players who previously created accounts. When a user (admin) tries to perform an action, the action listener receives the request and asks the user (admin) manager whether the credentials are valid and if it's OK to proceed. The manager checks its database and returns with an answer. Besides authorization, managers handle account registration and removal, and broadcasting messages to the network.

So a user (admin) tries to perform an action from the web browser. The action listener receives the request and forwards user credentials to the user (admin) manager. The manager checks whether the user (admin) is authorized to perform the action and returns an answer to the action listener. Keep in mind, the action listener and account managers are not people and they do not require manual operation. They are data structures with designated functions specified in chunks of code. I previously mentioned "smart contract logic" and, before that, Ethereum. So it's time for a digression. Ethereum has developed a big public blockchain with their own virtual machine. What this means is, one can create arbitrary applications and deploy them on the Ethereum blockchain, whereas one can only use Bitcoin on the Bitcoin blockchain. Theoretically, one could create a crowdfunding platform, digital casino, or a community voting center on Ethereum. However, writing the application logic for these applications is incredibly difficult and, when doing so, one must consider ways in which the system could do things we don't want it to do or users could attack or exploit the system. 

A smart contract is a piece of code that has an address, or location on the blockchain. Usually, a smart contract defines a specific action with a singular purpose. A bank on Ethereum might have separate smart contracts for depositing, withdrawing, and transferring funds between accounts. When a player sends funds and/or other data to the address of a smart contract, the corresponding code is executed. These might seem like elementary actions; however, there is a lot happening behind the scenes for the system to work properly and maintain security. For one, a player trying to move funds must have a valid account! If they are withdrawing, they must have the requisit funds to do so. If they are transferring funds to another account, the recipient account must exist and accept the transfer. These relatively simple actions live in a complex environment of conditions. Smart contracts help to itemize the actions and handle each in its own idiosyncratic web of contigencies.

Bringing this back to 3ii- the action listener, managers, and scorekeepers contain smart-contract logic for individual processes, some of which have been mentioned. However, the 3ii system does not run on Ethereum, so we do not have smart contracts with different addresses on the blockchain. Instead, we have our own private blockchain, courtesy of [Tendermint](http://tendermint.com/), and all of the smart-contract logic is contained in a single application! This paradigm is nice because it allows us to keep everything in one place, but we can still implement itemization of actions and separation of concerns: the account managers deal with account-related stuff, the scorekeepers keep track of service requests, and the action listener structures the game in which this all takes place.  

So at this point in the game, we encounter the scorekeepers. The player has tried an action, the action listener has passed off the credentials to the manager, and, in this case, the manager has authorized the player. Cool, so now we hand things off to the scorekeepers. These include the TMSP (Tendermint Socket Protocol) application- which contains our application state, the cache, and the feed. Suppose we are submitting a service request. The form contains our credentials, which have already been authorized, and information relating to the actual service request (e.g. service, address, description, etc.). The action listener sends this information, excluding the passphrase, to the TMSP application. The TMSP application checks whether the form, which I will refer to as the transaction, satisfies a certain pattern. If so, the transaction is broadcast to nodes in the network. This last part happens in the consensus engine layer (i.e. the blockchain). I won't go into detail of how this works; the application logic of 3ii is separate from the blockcahin processes. To learn more, you can check out Tendermint Core and the other awesome stuff Tendermint is doing.
